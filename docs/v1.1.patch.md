# Y 平面字幕相似度判定算法设计（v1.1.patch）

> 本文档基于 [v1.0 设计](v1.0.md)，记录补充的 v1.1 增强方案。若无特别说明，`compute_similarity` 对外接口保持不变，仅内部实现与指标含义做增强。`PATCH.md` 做为本补丁的原始记录，本文件为其正式文档化版本。

---

## 1. 难样本背景

| 场景 | 症状 | 原因 |
|------|------|------|
| ΔY 较大（≈15） | 放宽亮度波动后，SoftMask 变“松”，背景误检上升 | 仅凭绝对亮度判断字幕像素，导致噪声和背景进入掩码 |
| 同字幕但背景差异大 | SSIM/POC 受背景主导，结构相似度被稀释 | 背景纹理能量过强，文本贡献被稀释 |

目标：在不改变 API 的前提下，抑制背景、让评分更聚焦于字幕结构，并在 ΔY 较大时提高鲁棒性。

---

## 2. 改动总览

- **背景抑制**：新增 `_background_suppress`、`_local_mean_std`，通过局部 z-score / 高通压缩背景能量。
- **字幕概率升级**：`_subtitle_probability` 引入 ΔY 自适应斜率与局部对比度门控，强化文本像素判别。 
- **文本感知指标**：
  - Masked-SSIM（仅在字幕权重内计算结构相似度）。
  - 加权 POC（soft mask + Hann 窗，只让文本主导频域峰值）。
  - 容错 IoU（tIoU，掩码膨胀后求 IoU，抵抗 1–2 px 微移/描边差）。
- **自适应权重**：依据 `delta_norm` 与背景均值差 `bg_gap` 动态调整各指标权重。
- **指标/详情**：`metrics` 增加 tIoU、masked SSIM、加权 POC 等归一化值；`details` 新增 raw POC、bg gap、delta 等调试项。

---

## 3. 详细补丁

### 3.1 Patch A：辅助函数

> 新增背景抑制 / 绘窗 / Masked-SSIM / 加权 POC / 容错 IoU 等函数，直接置于 `similarity.py` 的工具区。

```python
import numpy as np
from numpy.lib.stride_tricks import sliding_window_view

def _local_mean_std(image: np.ndarray, radius: int = 5) -> Tuple[np.ndarray, np.ndarray]:
    k = radius * 2 + 1
    padded = np.pad(image, radius, mode="reflect")
    win = sliding_window_view(padded, (k, k))
    mean = win.mean(axis=(-1, -2))
    mean2 = (win * win).mean(axis=(-1, -2))
    var = np.maximum(mean2 - mean * mean, 0.0)
    std = np.sqrt(var + 1e-6)
    return mean.astype(np.float32), std.astype(np.float32)

def _background_suppress(image: np.ndarray, radius: int = None) -> np.ndarray:
    h, w = image.shape
    if radius is None:
        radius = max(3, min(h, w) // 64)
    m, s = _local_mean_std(image, radius=radius)
    z = (image - m) / (s + 1e-3)
    hp = 0.5 + 0.5 * np.tanh(z / 2.0)
    return hp.astype(np.float32)

def _hann2d(shape: Tuple[int, int]) -> np.ndarray:
    h, w = shape
    wy = np.hanning(h).astype(np.float32)
    wx = np.hanning(w).astype(np.float32)
    return np.outer(wy, wx)

def _ssim_masked(a: np.ndarray, b: np.ndarray, w: np.ndarray) -> float:
    w = np.clip(w.astype(np.float32), 0.0, 1.0)
    sw = float(w.sum())
    if sw < 1e3:
        return 0.0
    c1 = 0.01 ** 2
    c2 = 0.03 ** 2
    wa = w * a
    wb = w * b
    mu_a = float(wa.sum() / sw)
    mu_b = float(wb.sum() / sw)
    va = float(((w * (a - mu_a) ** 2).sum()) / sw)
    vb = float(((w * (b - mu_b) ** 2).sum()) / sw)
    cov = float((w * (a - mu_a) * (b - mu_b)).sum() / sw)
    num = (2 * mu_a * mu_b + c1) * (2 * cov + c2)
    den = (mu_a**2 + mu_b**2 + c1) * (va + vb + c2)
    return 0.0 if den <= 0 else float(np.clip(num / den, 0.0, 1.0))

def _phase_only_correlation_weighted(a: np.ndarray, b: np.ndarray, w: np.ndarray) -> Tuple[float, float]:
    eps = 1e-9
    w = np.clip(w.astype(np.float32), 0.0, 1.0)
    if w.max() <= 0:
        return 0.0, 0.0
    win = _hann2d(a.shape)
    ww = np.sqrt(w) * win
    aa = (a - float(a.mean())) * ww
    bb = (b - float(b.mean())) * ww

    fa = np.fft.fft2(aa)
    fb = np.fft.fft2(bb)
    cross = fa * np.conj(fb)
    mag = np.abs(cross)
    cross /= np.where(mag < eps, 1.0, mag)
    corr = np.real(np.fft.ifft2(cross))

    peak = float(np.max(corr))
    flat = corr.ravel()
    idx = int(np.argmax(flat))
    mask = np.ones_like(flat, dtype=bool)
    window = 9
    for off in range(-window, window + 1):
        pos = idx + off
        if 0 <= pos < flat.size:
            mask[pos] = False
    sidelobes = flat[mask]
    if sidelobes.size == 0:
        psr = 0.0
    else:
        mean = float(np.mean(sidelobes))
        std = float(np.std(sidelobes) + eps)
        psr = (peak - mean) / std
    return peak, psr

def _tolerant_iou(mask_a: np.ndarray, mask_b: np.ndarray, radius: int = 1) -> float:
    if radius <= 0:
        inter = np.logical_and(mask_a, mask_b).sum()
        union = np.logical_or(mask_a, mask_b).sum()
        return float(inter / union) if union > 0 else 0.0
    a = _morph_dilate(mask_a, radius)
    b = _morph_dilate(mask_b, radius)
    inter = np.logical_and(a, b).sum()
    union = np.logical_or(a, b).sum()
    return float(inter / union) if union > 0 else 0.0
```

### 3.2 Patch B：字幕概率

> 用下述实现替换原 `_subtitle_probability`，引入 ΔY 自适应斜率 + 局部对比度门控。

```python
def _subtitle_probability(image: np.ndarray, mu_sub: float, delta: float) -> np.ndarray:
    delta_eff = max(delta, 1.0 / 255.0)
    alpha0 = 8.0
    alpha = np.clip(alpha0 * (0.06 / (delta_eff + 1e-6)), 4.0, 12.0)

    dist = np.abs(image - mu_sub)
    p_mu = 1.0 / (1.0 + np.exp(-alpha * (delta_eff - dist) / delta_eff))

    m, s = _local_mean_std(image, radius=5)
    z = np.abs(image - m) / (s + 1e-3)
    p_contrast = np.tanh(z / 2.5)

    w_mu = 0.8 / (1.0 + (delta_eff / 0.06)) + 0.2
    return (w_mu * p_mu + (1.0 - w_mu) * p_contrast).astype(np.float32)
```

### 3.3 Patch C：`compute_similarity` 调用链

在原函数中插入背景抑制、高通版本、文本权重、bg gap 估计等步骤。主要变化：

1. `a_hp = _background_suppress(a_norm)`、`b_hp = _background_suppress(b_aligned)`；
2. `weight_text = np.minimum(soft_a, soft_b_shifted)` 供 Masked-SSIM / 加权 POC 使用；
3. `_compute_metrics` 调用新增参数 `weight_text`、`a_hp`、`b_hp_shifted`；
4. 取背景像素均值差 `bg_gap`，传入 `_metric_weights(delta, bg_gap)`。

示例片段：

```python
    a_hp = _background_suppress(a_norm)
    b_hp = _background_suppress(b_aligned)
    # ...
    weight_text = np.minimum(soft_a, soft_b_shifted)
    raw_metrics = _compute_metrics(
        mask_a, mask_b_shifted,
        a_hp, b_hp_shifted,
        weight_text=weight_text,
        a_raw=a_norm,
        b_raw=_shift_image(b_aligned, dx, dy, fill=float(b_aligned.mean()))
    )
    bg_gap = float(abs(bg_a.mean() - bg_b.mean())) if (bg_a.size and bg_b.size) else 0.0
    normalized_metrics = _normalize_metrics(raw_metrics)
    weights = _metric_weights(delta, bg_gap)
```

### 3.4 Patch D：指标与权重

> 替换 `_compute_metrics` / `_normalize_metrics` / `_metric_weights`，引入 tIoU、Masked-SSIM、加权 POC。`_normalize_peak`、`_normalize_psr` 可复用原实现。

```python
def _compute_metrics(
    mask_a: np.ndarray, mask_b: np.ndarray,
    a_hp: np.ndarray, b_hp: np.ndarray,
    weight_text: np.ndarray,
    a_raw: np.ndarray, b_raw: np.ndarray
) -> Dict[str, float]:
    intersection = np.logical_and(mask_a, mask_b).sum()
    union = np.logical_or(mask_a, mask_b).sum()
    total = mask_a.sum() + mask_b.sum()
    iou = float(intersection / union) if union > 0 else 0.0
    dice = float(2 * intersection / total) if total > 0 else 0.0
    tiou = _tolerant_iou(mask_a, mask_b, radius=1)

    ssim_masked = _ssim_masked(a_hp, b_hp, weight_text)
    projection = _projection_correlation(mask_a, mask_b)
    peak_raw, psr_raw = _phase_only_correlation(a_raw, b_raw)
    peak_w, psr_w = _phase_only_correlation_weighted(a_hp, b_hp, weight_text)

    return {
        "overlap_iou": iou,
        "overlap_dice": dice,
        "overlap_tiou": tiou,
        "structure_ssim": ssim_masked,
        "layout_projection": projection,
        "alignment_peak_raw": peak_raw,
        "alignment_psr_raw": psr_raw,
        "alignment_peak": peak_w,
        "alignment_psr": psr_w,
    }

def _normalize_metrics(raw: Dict[str, float]) -> Dict[str, float]:
    normalized = {
        "overlap_iou": raw.get("overlap_iou", 0.0),
        "overlap_dice": raw.get("overlap_dice", 0.0),
        "overlap_tiou": raw.get("overlap_tiou", 0.0),
        "structure_ssim": raw.get("structure_ssim", 0.0),
        "layout_projection": raw.get("layout_projection", 0.0),
        "alignment_peak": _normalize_peak(raw.get("alignment_peak", 0.0)),
        "alignment_psr": _normalize_psr(raw.get("alignment_psr", 0.0)),
    }
    for k, v in normalized.items():
        normalized[k] = float(np.clip(v, 0.0, 1.0))
    return normalized

def _metric_weights(delta_norm: float = 0.03, bg_gap: float = 0.0) -> Dict[str, float]:
    w = {
        "overlap_iou": 0.23,
        "overlap_dice": 0.12,
        "overlap_tiou": 0.16,
        "structure_ssim": 0.14,
        "layout_projection": 0.15,
        "alignment_peak": 0.10,
        "alignment_psr": 0.10,
    }
    if (delta_norm >= 0.06) or (bg_gap >= 0.08):
        w.update({
            "overlap_iou": 0.24,
            "overlap_dice": 0.11,
            "overlap_tiou": 0.19,
            "structure_ssim": 0.12,
            "layout_projection": 0.19,
            "alignment_peak": 0.07,
            "alignment_psr": 0.08,
        })
    s = sum(w.values())
    for k in w:
        w[k] = w[k] / s
    return w
```

---

## 4. 参数与兼容性

| 项目 | 建议 |
|------|------|
| `lambda_edge` | 默认 0.6 可用；ΔY 波动频繁可调到 0.65–0.7 |
| 容错 IoU 半径 | 1 像素为主；当 ROI 高度 > 120px 可设 2 |
| 置信度阈值 | 仍为 0.70 / 0.55；若验证集 ΔY 偏大，可将上阈微调至 0.68 |
| 依赖 | 仍仅依赖 `numpy`，无新第三方库；对外 API（请求/响应）不变 |

---

## 5. 验证建议

1. **同字幕 + ΔY={0,8,15,20} + 背景不变/变化**，观察 `overlap_tiou`、`alignment_psr`、`structure_ssim`；
2. **不同字幕但亮度相近**，确认 `p_contrast` 能抑制误检，`projection/tIoU` 显著下降；
3. **微移 ±2px / 描边差异**，验证 `tIoU` 优于普通 IoU；
4. 记录 `bg_gap` 与最终权重分布，确认自适应逻辑触发点符合预期。

---

## 6. 与 v1.0 的关系

- 本补丁完全兼容 v1.0 接口，实现层面可视为“增强模块”。
- 如需回退，可逐条撤销 Patch A–D；推荐在版本控制中以 `v1.1` tag 标记。
- `PATCH.md` 可以继续作为增量描述，`docs/v1.1.md` 则为正式算法文档。
