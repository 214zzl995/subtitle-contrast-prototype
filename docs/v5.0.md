# Y 平面字幕相似度判定算法设计（v5.0，OpenCV 方案）

v5.0 提供一条“基于 OpenCV 的工程化方案”，在保持既有接口不变的前提下，以 OpenCV 的形态学、边缘、距离变换、模板匹配与局部特征（ORB/BRISK）为主干，给出两帧字幕是否相同的稳定判定。该方案更偏实用工程实践，便于直接落地到 C++/Python 两端。

---

## 0. 目标与范围

- 目标：判断两帧在给定 ROI 内是否为相同字幕内容，输出分数与判决。
- 适用：
  - 脚本/工程更倾向 OpenCV 算子复用；
  - 中/稀疏字幕、轻微位移（≤3–4px），光照或对比度有变化但无缩放/旋转。
- 非目标：
  - 不做复杂频域特征融合；
  - 默认不考虑缩放/旋转（可用 ORB/RANSAC 作为补充路径）。

---

## 1. 依赖与接口兼容

- 依赖：`opencv-python >= 4.5`（或 C++ OpenCV 4.x），`numpy`。
- 接口：对外保持一致 `compute_similarity(config, repository, request) -> SubtitleSimilarityResult`。
- 选择：通过前端/后端 `version = "v5.0"` 选择本实现（可在 API 中新增路由绑定）。

---

## 2. 算法流程（OpenCV 版）

1) ROI 裁剪与归一（灰度 Y ∈ [0,255]）
- Python：直接使用帧仓库读取后切片。
- C++：使用 `cv::Mat roi(img, Rect(x,y,w,h))`。

2) 前景候选（硬阈值）
- 目标：在 `|Y-μ_sub| ≤ Δy` 的闭区间内得到布尔/二值掩码。
- 实现：`mask = cv.inRange(I, mu_sub-Δy, mu_sub+Δy)`（8U，0/255）。
- 形态学：`cv.morphologyEx` 做小核开/闭（如 `open(1x1) + close(2x1)`）连接细笔画、清理孤点。

3) 边缘提取（候选域内）
- 计算梯度：`cv.Sobel` 求 Gx/Gy，`cv.magnitude` 得幅值。
- 自适应阈值：在 `mask==255` 的像素上取 70% 分位，得到 `t`。
- 二值边缘：`edge = (grad >= t)` 再与 `mask` 按位与。
- 备选：直接用 `cv.Canny`，阈值由候选域内分位计算高/低阈。

4) 距离变换（Chamfer 路径）
- `DT = cv.distanceTransform(edge, cv.DIST_L2, mask_size=3)`（float32, px）。
- 在 `±r` 位移窗内，用整像素平移 `cv.warpAffine` 将对方边缘点或掩码平移后在 `DT` 上取样：
  - 单向部分 Chamfer：对采样距离做截断（4px）与截尾均值（保留最小 80%）。
  - 统计“紧密匹配”占比（≤1.5px）。
- 双向平均得到总代价与匹配率，取代价最小的 (dx,dy)。

5) 模板匹配（备选快速路径）
- 在候选掩码内将背景清零，使用 `cv.matchTemplate`（推荐 `TM_CCOEFF_NORMED`）。
- 位移窗内取最佳响应及其 PSR（主峰与旁瓣比）；模板大小建议为 ROI 或“行带”区域。
- 注意：OpenCV 对 `mask` 的支持仅限部分方法与版本；若不可用，可用“掩码内保留、外部设常值”替代。

6) 关键点特征（稀疏补充路径）
- 使用 ORB/BRISK：`cv.ORB_create(nfeatures=1000)`，只在 `mask==255` 的区域提取。
- 匹配：`cv.BFMatcher(NORM_HAMMING, crossCheck=True)` 或 ratio-test。
- 估计平移：RANSAC 拟合 2D 平移模型（或仿射，若允许微缩放），统计内点率与中位残差。
- 作为 Chamfer 的兜底/补充度量（当边缘过少或距离图退化时）。

7) 相似度归一与判决
- Chamfer 代价归一：`σ = 0.03 * diag(roi)`，`sim_core = exp(-(C/σ)^2)`。
- 轻惩罚：骨架/距离图估计中位笔画宽差 `Δw`，乘以 `exp(-(Δw/2)^2)`。
- 备选融合：当提供模板匹配或 ORB 匹配时，可取 `sim = max(sim_core, sim_tm, sim_orb)` 或小权重加和。
- 判决：`same` 当 `sim ≥ 0.60` 且 `match_frac ≥ 0.55`；否则 `different`（可按数据集微调）。

---

## 3. 关键实现片段（Python/OpenCV）

- 前景候选与形态学：
```python
mask = cv2.inRange(I, mu - dy, mu + dy)
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT, (1,1)))
mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_RECT, (2,1)))
```

- 梯度与阈值：
```python
gx = cv2.Sobel(I, cv2.CV_32F, 1, 0, ksize=3)
gy = cv2.Sobel(I, cv2.CV_32F, 0, 1, ksize=3)
mag = cv2.magnitude(gx, gy)
thr = np.percentile(mag[mask==255], 70) if np.any(mask) else np.percentile(mag, 70)
edge = (mag >= thr).astype(np.uint8) & (mask > 0)
```

- 距离变换与部分 Chamfer：
```python
DT = cv2.distanceTransform(edge, cv2.DIST_L2, 3)
# 单向部分 Chamfer
def chamfer_oneway(points, DT, dx, dy):
    H, W = DT.shape
    xs, ys = points[:,0] + dx, points[:,1] + dy
    ok = (xs>=0)&(xs<W)&(ys>=0)&(ys<H)
    d = DT[ys[ok], xs[ok]]
    d = np.minimum(d, 4.0)
    if d.size == 0: return np.inf, 0.0
    k = max(1, int(0.8 * d.size))
    d_sorted = np.sort(d)[:k]
    frac = float(np.mean(d <= 1.5))
    return float(np.mean(d_sorted)), frac
```

- 模板匹配（可选）：
```python
T = I1.copy(); T[mask1==0] = 0
S = I2.copy(); S[mask2==0] = 0
res = cv2.matchTemplate(S, T, cv2.TM_CCOEFF_NORMED)
val, _, _, _ = cv2.minMaxLoc(res)
```

- ORB（可选）：
```python
orb = cv2.ORB_create(1000)
kp1, des1 = orb.detectAndCompute(I1, mask1)
kp2, des2 = orb.detectAndCompute(I2, mask2)
# BF 匹配 + 位移鲁棒估计（RANSAC 平移）
```

---

## 4. 参数与默认

- `r=3`（搜索半径，整数像素）
- `grid_step=2, max_points=800`（边缘点子采样）
- `keep_quantile=0.80, clip_px=4.0, tight_px=1.5`（部分 Chamfer）
- `σ=0.03*diag(roi), τ_sim=0.60, τ_match=0.55`
- ORB：`nfeatures=1000`，ratio-test=0.75，RANSAC 内点阈=1.5px

---

## 5. 性能与复杂度

- 距离变换 `O(W·H)`；位移搜索 `O(|P|·(2r+1)^2)`；模板匹配 `O(W·H·k)`（k 为方法常数）。
- 640×180, r=3, |P|≈300–800：整体毫秒级；启用 ORB 时取决于特征数量与匹配筛选。

---

## 6. 局限与注意事项

- 仍不显式处理缩放/旋转；若存在，可启用 ORB+RANSAC 仿射模型，但注意误匹配与耗时。
- OpenCV 的 `matchTemplate(mask=...)` 支持依赖版本与方法；不满足时请使用“掩码外置零”替代。
- Δy 过大/过小均可能影响候选质量，建议结合数据做经验校准。

---

## 7. 与既有版本的关系

- v3.0：密文本下“行带+网格密度+峰表”更强；
- v4.0：稀疏点 + 部分 Chamfer 的纯 numpy 实现，依赖较少；
- v5.0：在 v4.0 思路上迁移到 OpenCV 算子与可选 ORB/模板匹配，便于工程化与跨语言统一。

---

## 8. 实现指引（similarity_v50.py，建议）

- 入口：`compute_similarity(config, repository, request)`（与现有一致）。
- 核心组件：
  - `cv.inRange` + `morphologyEx` 生成候选掩码；
  - `cv.Sobel` + 分位阈值得到候选域内边缘；
  - `cv.distanceTransform` + 位移窗内双向部分 Chamfer（主度量）；
  - 可选：`cv.matchTemplate` / `cv.ORB` + RANSAC 作为补充度量；
  - 统一映射到 [0,1] 分数并阈值判决。
- 调试输出：最优位移 (dx,dy)、部分 Chamfer 代价、匹配率、模板匹配峰值/PSR、ORB 内点率等。

---

## 9. 测试计划

- 维度：位移（0/±2/±4）、Δy（窄/中/宽）、背景（低/高）、密度（稀/中/密）。
- 目标：正样本分数集中 ≥0.7、负样本 ≤0.3；观察 ORB/模板匹配在极稀疏场景下的贡献。
- 消融：关闭 ORB/模板匹配，仅保留 Chamfer 验证主路径稳定性；反之亦然。

---

### 一句话总结

v5.0 以 OpenCV 算子为骨架，将硬阈值候选、候选域边缘、距离变换上的双向部分 Chamfer 作为主线，并提供模板匹配/ORB 匹配作为工程化补充，达到“实现简洁、跨端一致、易于调参”的字幕相似度判定方案。
