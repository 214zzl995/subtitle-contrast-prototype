# Y 平面字幕相似度判定算法设计（v6.0）
## 核心思路

**从像素 → 笔画证据 → 骨架/图 → 哈希/匹配**
不再和背景硬碰硬，而是只和“字的骨头”比。

---

## 步骤

### 1) 预处理：把细字拉出水面

* **放大**：ROI 先做 2–3× Lanczos 上采样，保证最窄笔画宽度 ≥2 像素。
* **亮度归一**：CLAHE 或局部均衡（Y 通道），压掉全局亮度差。
* **背景抑制**：guided filter 得到平滑背景 (B)，取 (R=Y-B)（顶帽），保留细结构。
* **颜色先验**：已知字幕颜色的 (Y_s) 与允许 (\Delta Y)，出一个文本似然
  [
  P_t = \exp!\big(-\frac{|R - \mu_{R,\text{local}}|}{\sigma_{R,\text{local}}}\big)\cdot \exp!\big(-\frac{|Y-Y_s|}{\Delta Y}\big)
  ]
  后续所有检测都在 (P_t) 上做权重。

### 2) 细笔画专用提取：SWT + MSER 融合

* **SWT（Stroke Width Transform）**：在 (R) 上做 Canny，按梯度方向成对搜边，得到**笔画宽**估计图 (W)。保留宽度位于 ([w_{\min}, w_{\max}]) 的连通域（上采样后一般 2–6 px）。
* **MSER**：在 (R) 或 (P_t\cdot R) 上跑 MSER，拿到稳定暗/亮区。
* **候选联合**：(M = \text{SWT_mask} \cup \text{MSER_mask})，再用细膨胀 + 小孔填补，得到**笔画前景掩码**。
* **骨架化**：对 (M) 做 Zhang‑Suen 或距变骨架，得到**单像素骨架** (S)，并记录每条骨架弧的平均笔画宽 (w)。

> 这步的目标是把“稀薄像素”浓缩成少量**骨架弧**，把背景彻底丢掉。

### 3) 对齐：只对齐骨架，不对齐背景

* **初对齐**：在骨架的**距离变换图** (D=\text{dist}(M)) 上做相位相关或 ECC，限制为仿射里仅平移+微缩放（±3%），得到 (T)。
* **基线校正**：以骨架下缘点的 RANSAC 直线作“行基线”，两帧都拉到同一基线水平。
  结果：两帧的骨架几乎重叠，避免背景干扰。

### 4) 相似度：快速哈希 + 精配对，双判据投票

**4.1 行轮廓哈希（快速粗判，极稳）**

* 对对齐后的前景 (M) 做每列的上/下边界 (t(x), b(x))，采样到固定长度（如 128）。
* 量化后拼成 128–256 bit 的二进制串（Top/Bottom/Height 三路可并），得到**行轮廓哈希** (H)。
* 同一字幕行的哈希 Hamming 距离 (d_H) 很小。设阈值 (d_H \le \tau_H) 直接判“相同候选”。

**4.2 骨架图匹配（精判）**

* 把骨架转为**图**：端点/交点为节点，弧段为边，边权为弧长，附带宽度 (w) 与方向 (\theta)。
* 用匈牙利或最短路把两图的边做匹配，代价：
  [
  c = \alpha,\text{Chamfer}(\text{edge}_A,\text{edge}_B)
  + \beta,|\log(w_A/w_B)|
  + \gamma,|\theta_A-\theta_B|
  ]
* 计算**匹配覆盖率**：
  [
  S_{\text{cov}}=\frac{\text{匹配到的骨架总弧长}}{\text{两帧骨架弧长并集}}
  ]
* 最终相似度：
  [
  S = S_{\text{cov}}\cdot \exp(-\bar c)
  ]
  判同阈值示例：(S\ge0.75) 且 (d_H\le \tau_H)（如 0.15·bits）。

> 这一步只比“骨架几何 + 宽度 + 方向”，基本不受背景纹理影响，细字也不会被稀释。

### 5) 时间维增强（可选但强烈建议）

如果有相邻帧，做一个 5–7 帧的滑窗：

* 对每帧得分 (S_t) 与 (d_{H,t}) 做加权中位数或**秩滤波**（rank filter）。
* 定义**行状态**：出现/持续/消失。只有当连续 (k) 帧低于阈值才判“换行”（抑制抖动和瞬时对齐误差）。
* 输出稳定的“同/不同”决策和置信度。

---

## 和你现有版本的关系

* 你已有的边缘/投影/Chamfer/距离变换都用过，但还是在“像素密度低”的坑里绕圈。上面方案把信息先浓缩成**骨架与行轮廓**，再配对，比直接在像素或稠密距离图上做要稳得多。
* v4 里有部分 Chamfer/Hausdorff，问题是没有“骨架图 + 宽度/方向”的拓扑约束，容易被背景细纹拉偏；哈希也能给你一个极快的早停条件。

---

## 关键参数与默认值

* 上采样倍数：2–3×（保证笔画宽 ≥2 px）。
* SWT 宽度窗：[2, 6]（像素，随上采样而调）。
* ECC 对齐：金字塔 3 层，迭代 30 次，尺度约束 ±3%。
* 哈希长度：128 或 256 bits；阈值 (\tau_H=0.15\cdot \text{bits})。
* 精配对阈：(S_{\text{cov}}\ge0.8)，(S\ge0.75)。
  建议以 ROC 调一轮即可稳定。

---

## 小型工程落地建议（C++/Python 都行）

1. ROI 裁切 → 上采样 → CLAHE → guided top‑hat。
2. Canny → SWT → MSER → 合并 → 形态修复 → 骨架化。
3. 距离图上做相位相关/ECC 得到平移与微缩放，对齐。
4. 生成行轮廓哈希做粗判，未通过直接“不同”。
5. 通过者做骨架图匹配，给出 (S) 与置信度。
6. 有多帧就加滑窗投票，输出稳定结果。

---

## 为什么它对“细而稀”的字有效

* **信号集中**：把零星高频像素变成连贯的骨架弧，匹配时信号量不再被背景均摊。
* **对齐更稳**：在距离场或骨架上对齐，不受人脸、桌面纹理影响。
* **判据互补**：哈希抗噪快，图匹配抗形变准，二者交叉验证降低误判。

